---
title: "Debugging and Functions in R"
subtitle: "Debugging - and some more - in R functions"
author: "Killian Conyngham and Carol Sobral"
date: "(Fall 2025) Introduction to Data Science"
output: 
    rmdformats::robobook:
    toc: TRUE
    df_print: paged
    number_sections: FALSE
    highlight: tango
    toc_depth: 3
    toc_float: true
    self_contained: false
---

```{=html}
<style>
.h1,h2,h3 {
color:#2f1a61;
}

.subtitle, section.normal {
color:#291854;
}

.title {
color:#cc0065;
}
</style>
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Welcome! `r emo::ji("wave")`


# 1. Debugging `r emo::ji("beetle")` 

When you write code, things will inevitably go wrong at some point. You can professionalize the way you:

-   fix unanticipated problems (debugging)
-   let functions communicate problems and take actions based on those communications (condition handling)
-   learn how to avoid common problems before they occur (defensive programming)

Potential problems are communicated via "conditions" (e.g., errors, warnings, and messages). For example

-   fatal errors are raised by `stop()` and force all execution to terminate
-   warnings are generated by `warning()` and display potential problems
-   messages are generated by `message()` and can provide informative output on the way

------------------------------------------------------------------------

## Debugging workflow

1.  Realize that you have a bug
2.  Make the bug repeatable: start with big chunk of code and narrow it down to isolate it
3.  Figure out where it is
4.  Fix it and test it

------------------------------------------------------------------------

## Debugging tools `r emo::ji("flashlight")`

The following function that calculates the geodesic distance between two points specified by radian latitude/longitude using the Haversine formula (hf); taken from [here](https://goo.gl/GezNGB), as an example. We've inserted some bugs here... `r emo::ji("bug")`

```{r eval = FALSE}
geod_dist <- function(lat1, lon1, lat2, lon2, earth.radius = 6371) {
  
  # from degrees to radians
  deg2rad <- function(deg) return(deg*pi/180)
  lon1 <- deg2rad(lon1)
  lat1 <- deg2rad(lat1)
  lon2 <- deg2rad(long2)
  lat2 <- deg2rad(lat2)
  
  # calculation
  delta.long <- (lon2 - lon1)
  delta.lat <- (lat2 - lat1)
  a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sing(delta.long/2)^2
  c <- 2 * asin(min(1,sqrt(a)))
  d = earth_radius * c
  return(d)
}

geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
```


### Trial and error `r emo::ji("graduation_cap")`

That is, if you see the error right away, try and fix it. You have lots of experience doing that. `r emo::ji("nerd_face")`


### Making function global `r emo::ji("globe")`

One way to approach debugging is to turn the arguments of the function into global objects (objects you can see in your environment, otherwise the objects are only available within your function). Then you can step through the code line by line to locate the bug.

```{r}
# make the objects that are otherwise entered as input parameters to your function global
lat1 <- 49.5; lon1 <-  8.4; lat2 <-  52.5; lon2 <- 13.4
```

```{r eval = FALSE}
# now, execute line by line
deg2rad <- function(deg) return(deg*pi/180)
lon1 <- deg2rad(lon1)
lat1 <- deg2rad(lat1)
lon2 <- deg2rad(long2)
lat2 <- deg2rad(lat2)
delta.long <- (lon2 - lon1)
delta.lat <- (lat2 - lat1)
a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sing(delta.long/2)^2
c <- 2 * asin(min(1,sqrt(a)))
d = earth_radius * c
return(d)
```

**Problem:** This creates global objects that match arguments names, which can become confusing and cause problems that become obvious when the function is called in a different environment. `r emo::ji("warning")`

> In case you choose this option, it is a good idea to clean your environment afterwards, or simply to remove all the new global objects using `rm()`.

**Side note** If you haven't done so already, as a general best practice advice, change the settings in your global options to "never" save the workspace as this can cause similar issues to the example described above.

```{r,  echo=F}
knitr::include_graphics("../pics/workspace.png", dpi = 100)
```


### Using `traceback()` `r emo::ji("point_left")`

```{r eval = FALSE}
geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
traceback()
```

This shows you where the error occurred (but not why). Read from bottom to top (e.g. 1. called function X, 2. called function Y, error occurred in line #6 of function Y)


### Using `browser()` `r emo::ji("fox")`

You can add `browser()` into your function somewhere before you expect the error.

**Note:** While `browser()` works best within a clean .R script, it can also help with troubleshooting within .Rmd files.

```{r eval = FALSE}
geod_dist <- function(lat1, lon1, lat2, lon2, earth.radius = 6371) {
  # from degrees to radians
  browser()
  deg2rad <- function(deg) return(deg*pi/180)
  lon1 <- deg2rad(lon1)
  lat1 <- deg2rad(lat1)
  lon2 <- deg2rad(lon2)
  lat2 <- deg2rad(lat2)
  # calculation
  delta.long <- (lon2 - lon1)
  delta.lat <- (lat2 - lat1)
  a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sin(delta.long/2)^2
  c <- 2 * asin(min(1,sqrt(a)))
  d = earth_radius * c
  return(d)
}
geod_dist(lat1 = 49.5, lon1 = 8.4, lat2 = 52.5, lon2 = 13.4)
```

You can then interactively work through the function line by line by hitting enter in the console or send additional lines of code.

```{r, echo=F}
knitr::include_graphics("../pics/browser.png", dpi = 100)
```

**Note:** Other helpful tools for debugging R functions written by someone else include `debug()` which automatically opens a debugger at the start of a function call and `trace()` which allows temporary code modifications inside functions that you can't easily access to (e.g. `ggplot()`).

------------------------------------------------------------------------

## Condition handling ```r emo::ji("ant")``r emo::ji("bee")``r emo::ji("ant") ```

Sometimes errors come expected, and you want to handle them automatically, e.g.:

-   model fails to converge
-   file download fails
-   stack processing of lists

Useful functions to deal with such cases: `try()` and `tryCatch()`

```{r eval = FALSE}
f1 <- function(x) { 
  log(x) 
  10 
} 

f1("x")
```


### Using `try()` `r emo::ji("person_shrugging")`

Ignore error:

```{r}
f1 <- function(x) { 
  try(log(x))
  10 
} 

f1("x")
```

Suppress error message:

```{r}
f1 <- function(x) { 
  try(log(x), silent = TRUE)
  10 
} 
f1("x")
```

Pass block of code to `try()`:

```{r}
try({ 
  a <- 1 
  b <- "x" 
  a + b 
})
```

Capture the output of `try()`:

```{r}
success <- try(1 + 2) 
failure <- try("a" + "b") 
class(success)
class(failure) 
```

Use `possibly()`, a function similar to `try()` from the purrr package when applying a function to multiple elements in a list. You can also provide a default value (here: `NA`) in case execution fails.

```{r eval = FALSE}
library(purrr)

elements <-list(1,2,3,"f")

results_a <- purrr::map(elements, log)
results_b <- purrr::map(elements, purrr::possibly(log, NA))
```


### Condition handling with `tryCatch()` `r emo::ji("fishing_pole")`

React to conditions, such as errors, warnings, messages, or interruptions, with certain actions "handlers". These are functions that map conditions to condition handler functions that can do anything but typically will return a value or create a more informative error message:

```{r}
show_condition <- function(code) { 
  tryCatch(code, 
           error = function(c) "error", 
           warning = function(c) "warning", 
           message = function(c) "message" )
}

show_condition(stop("!"))
show_condition(warning("?!"))
show_condition(message("?"))
```

If no condition is captured, `tryCatch()` returns the value of the input:

```{r}
show_condition(10+5)
```

A more real-life example of how to use `tryCatch()` is this one:

```{r}
model_selection <- function(data, formula1, formula2){
  
  tryCatch(lm(formula1, data), error = function(e) lm(formula2, data))
  
}
```

You try to fit `formula1` to the data, however, maybe it is a model with very strict requirements. You might also have a more robust (but maybe less interesting) `formula2` that you might fit if the requirements are not met and the modeling process throws an error.

Make more informative error messages:

```{r eval = FALSE}
read.csv_new <- function(file, ...) { 
  tryCatch(read.csv(file, ...), error = function(c) {
    c$message <- paste0(c$message, " (in file: ", file, ")") 
    stop(c) 
  })
}

read.csv("code/dummy.csv")
read.csv_new("code/dummy.csv")
```

------------------------------------------------------------------------

## Defensive programming `r emo::ji("shield")`

-   "making code fail in a well-defined manner"

-   "fail fast": as soon as something wrong is discovered, signal an error

-   Three rules to implement the "fail fast" principle:

1.  be strict about what you accept (e.g., only scalars)
2.  avoid functions that use non-standard evaluation, such as `subset()`, `transform()`, or `with()`
3.  avoid functions that return different types of output depending on their input (e.g. `sapply`)

------------------------------------------------------------------------


## Debugging Exercise `r emo::ji("skull")`

Here is a piece of code that comes with a few flaws. As an optional take-home exercise, please identify the bugs, remove them and report what you have done using comments.

```{r, eval = FALSE}
# load packages
# install.packages("LegislatoR")
library(LegislatoR) 

# get political data on German legislators
political_df <- 
  left_join(x = filter(get_political(legislature = "ger"), as.numeric("session") == 18), 
            y = get_core(legislature = "ger"), by = "pageid") 

# wiki traffic data
traffic_df <- 
  get_traffic(legislature = "ger") |> 
  filter(date >= "2013-10-22" & date <= "2017-10-24") |> 
  group_by(pageid) |> 
  summarize(traffic_mean = mean(traffic, na.rm = TRUE),
            traffic_max = max(traffic, na.rm = TRUE))

# sessions served
sessions_served_df <- 
  get_political(legislature = "deu") %% 
  group_by(pageid) |> 
  dplyr::summarize(sessions_served = n())

# merge
legislator_df <- 
  left_join(political_df, sessions_served_df, by = "pageid") |> 
  left_join(traffic_df, by = "pageid") 

# compute age
get_age <- function(birth, date_at) {
  date_at_fmt <- date_at
  birth_fmt <- birth
  diff <- difftime(lubridate::ymd(birth_fmt), lubridate::ymd(date_at_fmt))
  diff_years <- time_length(diff, "years") 
  diff_years
}
legislator_df$age_in_years <- round(get_age(legislator_df$birth, "2017-10-24"), 0)

# plot top 10 pageviews
legislator_df <- arrange(legislator_df, desc(traffic_mean))
legislator_df$rank <- 1:nrow(legislator_df)
legislator_df_table <- dplyr::select(rank, name, traffic_mean, traffic_max) 
names(legislator_df_table) <- c("Rank", "Representative", "Mean", "Maximum") 
legislator_df_table <- head(legislator_df_table, 10)

ggplot(legislator_df_table, aes(y = Mean, x = -Rank)) + 
  xlab("Rank") + ylab("Avg. daily page views") + 
  labs(title = "Top 10 representatives by average daily page views") + 
  geom_bar(stats = "identity") + # change to geom_col
  scale_x_continuous(breaks = -nrow(legislator_df_table):-1, labels = rev(1:nrow(legislator_df_table))) # add +
geom_text(aes(y = 10, label = Representative), hjust = 0, color = "white", size = 2) + 
  coord_flip() + 
  theme_minimal()

# run model of page views as a function of sessions served, party, sex, and age in years
legislator_df$traffic_log <- log(legislator_df$traffic_mean)

covars <- c("sessions_served", "party", "sex", "age_in_years")
fmla <- paste("traffic_log", paste(covars, collapse = " - "), sep = " ~ ") 
summary(log_traffic_model <- lm(fmla, legislator_df))

# plot table
sjPlot::tab_model(log_traffic_model)


Let's take a deeper look into functionality in R

```

---


# 2. More on Functions


## Important Concepts

### What is an R function?

* Functions in R are objects, just as data frames, vectors and lists are.
* Functions allow us to group code lines that serve a purpose and make them reusable.
* Functions are the abstract form of how a the code works.
* They can be broken down into 3 components: arguments, body and environment.

### Syntax and components of a function

A function in R will have the following structure:

```
first_function <- function(arguments){
  body of function
  }
```

And the components will be:

1. **Arguments**: what are the inputs that your function will work with. Called with *formals(function)*.
2. **Body**: this is the code inside the function. What you want to do with the inputs and define outputs. Called with *body(function)*
3. **Environment**: the data structure where your function finds the values associated with the inputs. *environment(function)*

```{r}
# function of summation
f_1 <- function(x,y){
  # sum of inputs
  result = x+y
  return(result)
}

formals(f_1)
# returns x and y

body(f_1)
# returns code inside of {}

environment(f_1)
# where the function is looking for x and y
```

-----


## Types of Functions `r emo::ji("alien")`

### Primitive Functions

These are the functions present in baseR and don't require any package loading or function construction. They directly call C code to run, and are the exception to the rule of the three components.

All of these are primitive functions:

* sum()
* mean()
* sqrt()
* min()
* max()

```{r}
sum
```
They can be either built in or special types. Closure type function are those that capture their environments.

```{r}
typeof(sum)
typeof(`[`)
typeof(f_1)
```

```{r}
formals(sum)
body(sum)
environment(sum)
```


### First Class Functions

Functions you create or load in R are objects, this property is called "First-Class Functions".  

You can name your functions or you can create anonymous ones, depending on your objective. Remember purrr's anonymous functions?

```{r}
purrr::map_int(1:3, ~.x + 1)
```

-----

## Building Functions `r emo::ji("pencil")`

### Basic Functions in R

Previously we saw how the basic syntax of a function looks. We can use it as a guide to build our own functions in R.

When naming functions, a good practice to follow is to use **verbs** for the desired protocol to follow. Another good practice is to names them in an intuitive manner like "roll_the_dice". The most used arguments in basic functions are `x` and `y`.

Both baseR functions and arithmetic can be used to manipulate values.

The `...` is used to add non-specified arguments to the function.

```{r}
summation <- function(x,y, ...){
  result = sum(x,y,...)
  return(result)
}

summation(1,2,3,4,5,c(1,2,3,4))
```

We can also specify default values to the arguments of a function:

```{r}
# create dice simulation, and specify number of times to roll the dice
roll_the_dice <- function(n_times = 1){
  result = sample(1:6, n_times, replace = TRUE)
  return(paste("Rolling the dice",as.character(n_times),"times:",paste0(result, collapse = "-")))
}

roll_the_dice()
roll_the_dice(5)
```

-----

## Conditional Statements in Functions

`if statements` allow for condition handling in functions.

Syntax
```
if(condition){
  what you want to happen if condition is true
} else {
  if condition is not true then do this
}
```


```{r}
roll_the_dice <- function(n_times = 1){
  if(!is.numeric(n_times)){
    print("Noup, I need a numerical input to work. Try again!")
  } else {
    result = sample(1:6, n_times, replace = TRUE)
  return(paste("Rolling the dice",as.character(n_times),"times:",paste0(result, collapse = "-")))
  }
}


roll_the_dice("Hallo")
```

### Error Handling

You can use if statements to handle errors, like in the last function. Let's see some other ways. You can use `stop()` to tell R what to output in case of an error where it cannot evaluate the function. 

```{r}
roll_the_dice <- function(n_times = 1){
  stop("Really, I need a number as an input")
  result = sample(1:6, n_times, replace = TRUE)
  return(paste("Rolling the dice",as.character(n_times),"times:",paste0(result, collapse = "-")))
}

# this produces an error with the desired message
# roll_the_dice(list(2))
```

Sometimes you want your function to be flexible and ignore or skip errors. You can use try() for this.

```{r}
#purrr::map(c(1,2,"three"), roll_the_dice)
```


```{r}
roll_the_dice <- function(n_times = 1){
  try(sample(1:6, n_times, replace = TRUE))
}

#purrr::map(c(1,2,"three"), roll_the_dice)
```
`try()` does not allow assigning names within it. If you want to do something further than ignoring the error you can use `tryCatch()`

```
f_1 <- function(name_input){
  tryCatch({your_function},
           error = function(e)
                    {e})
}
```

```{r}
roll_the_dice <- function(n_times = 1){
  tryCatch({
    result <- sample(1:6, n_times, replace = TRUE)
    return(paste("Rolling the dice", as.character(n_times),"times:",paste(result, collapse = "-")))},
    error = function(e){
      return(paste(paste0("'",as.character(n_times),"'"), "is not a numeric input..."))
    }
    )
}

purrr::map(c(1,2,"three"), roll_the_dice)
```

-----

## Creating More Complex Functions

We can also add some elements we have worked with in past sessions. Let's create a function that creates possible variations of how a person can be called in documents.

This function works with names that have one first name and one last name, e.g. "Wael Sawan", CEO of Shell.

Possible variations:

Wael Sawal
W. Sawal
W Sawal
Wael S.
Wael S
W.S.

- Pseudocode - writing the steps I want my function to make in paper

first: split_name into first and last

construct variations:
complete  name
include first capital letter of name and complete last name
include first capital letter of name + . + complete last name
...

store them in a vector


```{r}
strsplit("Wael Sawan", " ")[[1]]
```



```{r}
generate_name_variations <- function(full_name) {
  tryCatch({
    # Split the name into first and last name
    name_parts <- strsplit(full_name, " ")[[1]]
    
    # Ensure that the name has exactly two parts
    if (length(name_parts) != 2) {
      stop("The input must be a two-word name.")
    }
    
    first_name <- name_parts[1]
    last_name <- name_parts[2]
    first_initial <- substr(first_name, 1, 1)
    last_initial <- substr(last_name, 1, 1)
    
    # Create the variations
    variations <- c(
      paste0(first_initial, ".", last_initial, "."),
      paste0(first_initial, ".", " ", last_initial, "."),
      paste0(first_initial, ".", " ", last_name),
      paste0(first_initial, " ", last_name),
      paste0(first_name, " ", last_name),
      paste0(first_name, " ", last_initial, "."),
      paste0(first_name, " ", last_initial)
    )
    
    return(variations)
  }, error = function(e) {
    # Handle the error and return a message
    return(paste("Error:", e$message))
  })
}

# Apply the function to a vector of names, using purrr::map or lapply
names_vector <- c("Wael Sawan", "John", "", "Alice Johnson", "NotAName")
purrr::map(names_vector, generate_name_variations)
```

Let's simplify this to show no output and create a regex pattern:

```{r}
generate_name_variations <- function(full_name) {
  tryCatch({
    # Split the name into first and last name
    name_parts <- strsplit(full_name, " ")[[1]]
    
    # Ensure that the name has exactly two parts
    if (length(name_parts) != 2) {
      e = ""
    } else
    {
    first_name <- name_parts[1]
    last_name <- name_parts[2]
    first_initial <- substr(first_name, 1, 1)
    last_initial <- substr(last_name, 1, 1)
    
    # Create the variations
    variations <- c(
      paste0(first_initial, ".", last_initial, "."),
      paste0(first_initial, ".", " ", last_initial, "."),
      paste0(first_initial, ".", " ", last_name),
      paste0(first_initial, ".", last_name),
      paste0(first_initial, " ", last_name),
      paste0(first_name, " ", last_name),
      paste0(first_name, " ", last_initial, "."),
      paste0(first_name, " ", last_initial),
      last_name
    )
    
    return(paste(variations, collapse = "|"))}
  }, error = function(e) {
    # return empty
    e
  })
}

# Apply the function to a vector of names, using purrr::map or lapply
names_vector <- c("Wael Sawan", "John", "", "Alice Johnson", "NotAName")
purrr::map(names_vector, generate_name_variations)
```

We can use the function to create variations of a list of names and create a string to match in a text. Let's use the names of the [Alabama US congress members](https://www.house.gov/representatives).

```{r}
al_cong <- c("Jerry Carl","Barry Moore","Miker Rogers","Robert Aderholt","Dale Strong","Gary Palmer","Sewell Terri")

texts_to_look <-c("J Carl is a congress member of the US","Robert A. and Strong are frequently seen discussing laws", "G.P. is from Alabama")

# Function to check if any variations of the name are mentioned in the texts
check_name_in_texts <- function(name, texts) {
  # Generate the name variations
  variations <- generate_name_variations(name)
  
  # Create a logical vector for each text, checking if any variation is found
  sapply(texts, function(text) {
    any(sapply(variations, function(variation) grepl(variation, text, ignore.case = TRUE)))
  })
}

# Create a data frame with names as rows and texts as columns
result_matrix <- sapply(al_cong, function(name) check_name_in_texts(name, texts_to_look))
result_df <- as.data.frame(t(result_matrix))

# Name the columns as text1, text2, etc.
colnames(result_df) <- paste0("text", seq_along(texts_to_look))

# Add the names of congress members as a column
result_df <- cbind(Name = al_cong, result_df)

# View the result
result_df <- as.data.frame(result_df)
row.names(result_df) <- NULL

result_df
  
```



---

References:

* Hadley Wickham. **Advanced R** Available at: https://adv-r.hadley.nz/functions.html#functionshttps://adv-r.hadley.nz/functions.html#functions
* Introduction to Data Science. Session 03 Tidyverse and Function. (2024). Hertie School. https://github.com/intro-to-data-science-24/labs/tree/main/session-03-tidyverse-functions
* ChatGPT was used to make code more efficient

